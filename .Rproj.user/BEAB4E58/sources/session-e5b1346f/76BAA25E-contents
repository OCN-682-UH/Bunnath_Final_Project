server <- function(input, output, session) {
  
  # --- Setup for Choice Tasks (Inside Server for Multi-User Safety) ---
  nct_shown <- 2
  
  # Randomly select the rows from the design matrix
  rct <- sample(seq_len(nrow(design)), nct_shown)
  
  # Create the two choice task tables using the defined function
  ct_shown_1 <- create_choice_task(rct[1], 1)
  ct_shown_2 <- create_choice_task(rct[2], 2)
  
  # --- Welcome Tab Logic ---
  observeEvent(
    input$goButton, {
      req(input$username)
      shinyjs::alert(paste("Welcome,",
                           input$username,
                           "! Let’s explore discrete choice experiment together!")
      )
    }
  )
  
  output$welcome_text <- renderText({
    if (input$username != "") {
      paste("Hi",
            input$username,
            "— today is",
            format(input$date, "%A, %B %d, %Y")
      )
    } else {
      paste("Please enter your name to begin.")
    }
  }
  )
  
  output$value <- renderPrint(
    {input$date}
  ) 
  
  # --- Survey Tab Logic ---
  
  # Define a set of mandatory fields
  mandatory_fields <- c("gender", "age", "edu")
  
  # Observer: Intro to Socdem
  observeEvent(
    input$click2socdem, {
      hide("intro")
      show("socdem")
      
      #Only show next button when answers are filled
      observe({
        mandatory_filled <- vapply(
          mandatory_fields,
          function(x) {
            !is.null(input[[x]]) && input[[x]] != ""
          },
          logical(1)
        )
        
        # Check if all mandatory fields are filled
        mandatory_filled <- all(mandatory_filled)
        
        # Toggle the next button
        toggleState(
          id = "click2explanation",
          condition = mandatory_filled && !is.na(input$age) && input$age >= 16
        )
      })
    }
  )
  
  # Observer: Socdem to Explanation
  observeEvent(
    input$click2explanation, {
      hide("socdem")
      show("explanation")
    }
  )
  
  # Observer: Explanation to Choice Task 1
  observeEvent(
    input$click2choice1, {
      hide("explanation")
      show("choicetask1")
      
      #Only show next button when a choice is selected:
      observe({
        toggleState(
          id = "click2choice2",
          condition = !is.null(input$ct1)
        )
      })
    }
  )
  
  # Observer: Choice Task 1 to Choice Task 2
  observeEvent(
    input$click2choice2, {
      hide("choicetask1")
      show("choicetask2")
      show("submit")
      
      #Only show next button when a choice is selected:
      observe({
        toggleState(
          id = "click2thanks",
          condition = !is.null(input$ct2)
        )
      })
    }
  )
  
  # Reactive object to temporarily save the user's data
  form_data <- reactive({
    tibble(
      cm1 = input$ct1,
      cm2 = input$ct2,
      cs1 = rct[1],
      cs2 = rct[2],
      gender = input$gender,
      age = input$age,
      edu = input$edu,
      protest = input$protest # will be NULL if skipped
    )
  })
  
  # Observer: Submit button logic (Choice Task 2, Protest, Saving, Thank you)
  observeEvent(
    input$click2thanks, {
      
      # Show protest question if all choices are for the Status Quo (assuming Prog 1 is SQ)
      if (input$ct1 == "Prog 1" && input$ct2 == "Prog 1") {
        hide("choicetask2")
        hide("submit")
        show("protest")
        
        # Enable the next button only when text is entered
        observe({
          toggleState(
            id = "click2thanksprotest",
            condition = nchar(input$protest) > 0
          )
        })
        
        # Save data after protest question is answered
        observeEvent(
          input$click2thanksprotest, {
            hide("protest")
            show("savingmessage")
            # Save data using the multiple-file method
            saveData(form_data)
            hide("savingmessage")
            show("thankyou")
          }
        )
        
      } else { # If not protesting, proceed to save directly
        hide("choicetask2")
        hide("submit")
        show("savingmessage")
        # Save data using the multiple-file method
        saveData(form_data)
        hide("savingmessage")
        show("thankyou")
      }
    }
  )
  
  # Render the choice task tables
  output$tct1 <- renderTable(
    ct_shown_1,
    sanitize.text.function = function(x) {
      x
    },
    align = c("lccc"),
    width = "90%",
    spacing = "s",
    striped = TRUE
  )
  
  output$tct2 <- renderTable(
    ct_shown_2,
    sanitize.text.function = function(x) {
      x
    },
    align = c("lccc"),
    width = "90%",
    spacing = "s",
    striped = TRUE
  )
  
  # Final observer to ensure that the app closes when the user is done
  observeEvent(input$close, {
    stopApp()
  })
  
  # Exploring data tab
  wind_dataset <- reactive({
    wind_data[sample(nrow(wind_data), input$sampleSize),]
  })
  
  output$plot <- renderPlot({
    
    p <- ggplot( wind_dataset(), aes_string(x=input$x, y=input$y)) + geom_point()
    
    if (input$color != 'None')
      p <- p + aes_string(color=input$color)
    
    facets <- paste(input$facet_row, '~', input$facet_col)
    if (facets != '. ~ .')
      p <- p + facet_grid(facets)
    
    if (input$jitter)
      p <- p + geom_jitter()
    if (input$smooth)
      p <- p + geom_smooth()
    
    print(p)
  })
}

# Run the application
shinyApp(ui = ui, server = server)